#####		Functions for MWM analysis

####		fullRankProcessing:		Takes in a data sets (fullData), extracts the variables named by orderedValueNames 
####								(should be ordered so first trial name is given first, second trial name is second, etc), 
####								computes the rank at each time and then takes a weighted average of the ranks
####								If we are expecting a learning difference (i.e. groups are similar early on but different later)
####								then it makes sense to use weights that are heavier toward the end of the trials
####								I prefer to use linear weights, i.e., if there are 10 trials then weights are 1:10 (they are automatically scaled)
####
####								Important note: censored values should be replaced with Inf!	
####	
####								R tip: it will often be easy to generate the orderedValueNames using R's paste0 function. For example,
####								if the names are trial1, trial2, trial3,..., trial24, this can be generated by 
####								paste0('trial', 1:24)

####		getRankValues:			Takes in data set (data) and returns the ranked values at each of the orderedVarNames. Returns
####								a dataframe of ranks. p_rank is an indicator for whether the percentile should be returned 
####								(i.e. 1/n, 2/n, 3/n, etc) instead of the raw rank (i.e. 1, 2, 3, etc)
####								This function is used by fullRankProcessing

####		plotConfIntervals:		Used for plotting confidence intervals for two or more groups across several trials
####								We should be plotting confidence intervals for the average rank score at each time point
####								to account for censoring, rather than the raw values
####								fullData = data, orderedVarNames = ordered names of outcome variables, grpName = name of genotype
####								cols = colors of confidence intervals plotted. Should be one color per group level
####								grpLvls = levels of group variable to be used. Default is all
####								useRanks = should we be plotting confidence intervals for ranks or raw values?
####								... = additional arguments to be passed to plot(). So you can do something like 
####								plotConfIntervals(blah blah, xlab = 'trial number') and it will add a label to the x-axis

rankAnalysis <- function(formula, data, orderedScoreNames, w = NULL){
  adjustVar = TRUE
  data[['rankScores']] <- fullRankProcessing(data, orderedScoreNames, weights = w)
  if(length(formula) == 2) formula[[3]] <- formula[[2]]
  formula[[2]] <- as.name('rankScores')
  lmFit <- lm(formula, data = data)
  ans <- new('rankAnalysisClass')
  ans$rawData <- data
  ans$rankValues <- data$rankScores
  ans$coefficients <- lmFit$coef
  ans$df <- lmFit$df.residual
  if(!adjustVar){
    ans$varianceMat <- vcov(lmFit)
  }
  else{
    n <- nrow(lmFit$model)
    xmat <- model.matrix(lmFit)
    obsCorMat <- matrix(-1/n, nrow = n, ncol = n)
    diag(obsCorMat) <- 1
    obsVarMat <- obsCorMat * sum(lmFit$residuals^2)/ans$df
    newVar <- solve(t(xmat) %*% xmat) %*% t(xmat) %*% obsVarMat %*% xmat %*% t( solve(t(xmat) %*% xmat))
    ans$varianceMat <- newVar
  }
  return(ans)
}


	
fullRankProcessing <- function(fullData, orderedValueNames, weights = NULL){
	rankValues <- getRankValues(fullData, orderedValueNames)
	rankSums <- getMeanRankVals(rankValues, colnames(rankValues),  w = weights)
	return(rankSums)
}


getRankValues <- function(data, orderedVarNames, p_rank = TRUE){
	rankNames <- paste(orderedVarNames, 'rank', sep = '_')
	nRow <- nrow(data)
	output <- data.frame(DUMMYVAR = 1:nRow)
	for(vN in orderedVarNames){
		rN <- paste(vN, 'rank', sep = '_')
		if(!is.numeric(data[[vN]]))		stop('values are not numeric!')
		theseRanks <- rank(data[[vN]], ties = 'average')
		if(p_rank)
			theseRanks <- theseRanks/length(theseRanks)
		output[[rN]] <- theseRanks
	}
	output$DUMMYVAR = NULL
	return(output)
}

getMeanRankVals <- function(rankData, orderedRankNames, w = NULL){
  if(is.null(w))
    w = rep(1, ncol(rankDataOnly))
	if(length(w) != length(orderedRankNames))	stop('length(rankNames) != length(w)')
	rankDataOnly <- rankData[orderedRankNames]
	sumVals = as.numeric(w %*% t(as.matrix(rankDataOnly))) / sum(w)
	return(sumVals)
}


plotConfIntervals <- function(fullData, orderedVarNames, grpName, 
							  cols = c('blue', 'red'), grpLvls = levels(factor(fullData[[grpName]])),
							  useRanks = T, 
							  ...){
	xLimits <- c(0.5, length(orderedVarNames) + 0.5)
	if(length(cols) != length(grpLvls))	stop('number of colors must match number of grpLvls')
	grp_k <- length(grpLvls)
	ci.l <- matrix(nrow = grp_k, ncol = length(orderedVarNames))
	ci.h <- ci.l
	
	grpId <- fullData[[grpName]]
	
	for(i in seq_along(orderedVarNames)){
		vn <- orderedVarNames[i]
		theseVals <- fullData[[vn]]
		if(useRanks)	theseVals <- rank(theseVals, ties.method = 'average') / length(theseVals)
		for(j in 1:grp_k){
			grpVals <- theseVals[grpId == grpLvls[j] ]
			thisMean <- mean(grpVals, na.rm = TRUE)
			thisSE <- sd(grpVals, na.rm = TRUE)/sqrt(length(grpVals))
			ci.l[j,i] <- thisMean - 1.96 * thisSE
			ci.h[j,i] <- thisMean + 1.96 * thisSE
		}
	}
	
	yLimits <- c(min(as.numeric(ci.l)), max(as.numeric(ci.h)))
	plot(NA, xlim = xLimits, ylim = yLimits, ...)
	
	for(i in seq_along(orderedVarNames)){
		vn <- orderedVarNames[i]
		for(j in 1:grp_k){
			ci.l[j,i] -> thisLower
			ci.h[j,i] -> thisUpper
			thisMean <- (thisUpper + thisLower) /2
			lines(c(i + j/10, i+j/10) , c(thisLower, thisUpper), col = cols[j])
			lines(c(i-0.2+j/10, i+0.2+j/10), c(thisLower, thisLower), col = cols[j])
			lines(c(i-0.2+j/10, i+0.2+j/10), c(thisUpper, thisUpper), col = cols[j])
			lines(c(i-0.1+j/10, i+0.1+j/10), c(thisMean, thisMean), col = cols[j])
		}
	}	
}


rankAnalysisClass <- setRefClass('rankAnalysisClass',
                                 fields = c('coefficients', 'varianceMat', 'rankValues', 'rawData', 'df'),
                                 methods = list(
                                   makeSummary = function(){
                                   betas <- coefficients
                                   se <- sqrt(diag(varianceMat))
                                   tval <- betas / se
                                   pval <- 2 * pt(-abs(tval), df = df)
                                   ans <- data.frame(Estimate = coefficients, SE = se, t_value = tval, p_value = pval)
                                   return(ans)
                                 },
                                 show = function(){
                                   print(makeSummary())
                                 }))

summary.rankAnalysisClass <- function(object, ...) object$makeSummary()