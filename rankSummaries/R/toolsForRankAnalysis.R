#####		Functions for MWM analysis

####		fullRankProcessing:		Takes in a data sets (fullData), extracts the variables named by orderedValueNames 
####								(should be ordered so first trial name is given first, second trial name is second, etc), 
####								computes the rank at each time and then takes a weighted average of the ranks
####								If we are expecting a learning difference (i.e. groups are similar early on but different later)
####								then it makes sense to use weights that are heavier toward the end of the trials
####								I prefer to use linear weights, i.e., if there are 10 trials then weights are 1:10 (they are automatically scaled)
####
####								Important note: censored values should be replaced with Inf!	
####	
####								R tip: it will often be easy to generate the orderedValueNames using R's paste0 function. For example,
####								if the names are trial1, trial2, trial3,..., trial24, this can be generated by 
####								paste0('trial', 1:24)

####		getRankValues:			Takes in data set (data) and returns the ranked values at each of the orderedVarNames. Returns
####								a dataframe of ranks. p_rank is an indicator for whether the percentile should be returned 
####								(i.e. 1/n, 2/n, 3/n, etc) instead of the raw rank (i.e. 1, 2, 3, etc)
####								This function is used by fullRankProcessing

####		plotConfIntervals:		Used for plotting confidence intervals for two or more groups across several trials
####								We should be plotting confidence intervals for the average rank score at each time point
####								to account for censoring, rather than the raw values
####								fullData = data, orderedVarNames = ordered names of outcome variables, grpName = name of genotype
####								cols = colors of confidence intervals plotted. Should be one color per group level
####								grpLvls = levels of group variable to be used. Default is all
####								useRanks = should we be plotting confidence intervals for ranks or raw values?
####								... = additional arguments to be passed to plot(). So you can do something like 
####								plotConfIntervals(blah blah, xlab = 'trial number') and it will add a label to the x-axis

rankAnalysis <- function(formula, data, orderedScoreNames, w = NULL){
  adjustVar = T
  data[['rankScores']] <- fullRankProcessing(data, orderedScoreNames, weights = w)
  if(length(formula) == 2) formula[[3]] <- formula[[2]]
  formula[[2]] <- as.name('rankScores')
  lmFit <- lm(formula, data = data)
  ans <- new('rankAnalysisClass')
  ans$rawData <- data
  ans$rankValues <- data$rankScores
  ans$coefficients <- lmFit$coef
  ans$df <- lmFit$df.residual
  ans$.lmFit <- lmFit
    if(!adjustVar){
    ans$varianceMat <- vcov(lmFit)
  }
  else{
    n <- nrow(lmFit$model)
    xmat <- model.matrix(lmFit)
    obsCorMat <- matrix(-1/(n-1), nrow = n, ncol = n)
    
    obsCorMat <- obsCorMat * 0
    
    diag(obsCorMat) <- 1
    obsVarMat <- obsCorMat * sum(lmFit$residuals^2)/(ans$df+1)
    newVar <- solve(t(xmat) %*% xmat) %*% (t(xmat) %*% obsVarMat %*% xmat) %*% t( solve(t(xmat) %*% xmat))
    ans$varianceMat <- newVar
  }
  return(ans)
}


	
fullRankProcessing <- function(fullData, orderedValueNames, weights = NULL){
	rankValues <- getRankValues(fullData, orderedValueNames)
	rankSums <- getMeanRankVals(rankValues, colnames(rankValues),  w = weights)
	return(rankSums)
}


getRankValues <- function(data, orderedVarNames, p_rank = TRUE){
	rankNames <- paste(orderedVarNames, 'rank', sep = '_')
	nRow <- nrow(data)
	output <- data.frame(DUMMYVAR = 1:nRow)
	for(vN in orderedVarNames){
		rN <- paste(vN, 'rank', sep = '_')
		if(!is.numeric(data[[vN]]))		stop('values are not numeric!')
		theseRanks <- rank(data[[vN]], ties = 'average')
		if(p_rank){
			theseRanks <- theseRanks/length(theseRanks)
		}
		output[[rN]] <- theseRanks
	}
	output$DUMMYVAR = NULL
	return(output)
}

getMeanRankVals <- function(rankData, orderedRankNames, w = NULL){
  rankDataOnly <- rankData[orderedRankNames]
  if(is.null(w))
    w = rep(1, ncol(rankDataOnly))
	if(length(w) != length(orderedRankNames))	stop('length(rankNames) != length(w)')
	sumVals = as.numeric(w %*% t(as.matrix(rankDataOnly))) / sum(w)
	return(sumVals)
}


plotConfIntervals <- function(fullData, orderedVarNames, grpName, 
							  cols = c('blue', 'red'), grpLvls = levels(factor(fullData[[grpName]])),
							  useRanks = T, ylow = NULL, yhi = NULL, errorSummary = 'ci',
							  useTrialNums = NULL, adj_x = 0.05,
							  ...){
	xLimits <- c(0.5, length(orderedVarNames) + 0.5)
	if(length(cols) != length(grpLvls))	stop('number of colors must match number of grpLvls')
	grp_k <- length(grpLvls)
	ci.l <- matrix(nrow = grp_k, ncol = length(orderedVarNames))
	ci.h <- ci.l
	
	grpId <- fullData[[grpName]]
	
	z <- NA
	if(errorSummary == 'ci') z <- 1.96
	else if (errorSummary == 'se') z <- 1
	else stop('errorSummary not recognized. Options = "ci" or "se"')
	
	for(i in seq_along(orderedVarNames)){
		vn <- orderedVarNames[i]
		theseVals <- fullData[[vn]]
		if(useRanks)	theseVals <- rank(theseVals, ties.method = 'average') / length(theseVals)
		for(j in 1:grp_k){
			grpVals <- theseVals[grpId == grpLvls[j] ]
			thisMean <- mean(grpVals, na.rm = TRUE)
			thisSE <- sd(grpVals, na.rm = TRUE)/sqrt(length(grpVals))
			ci.l[j,i] <- thisMean - z * thisSE
			ci.h[j,i] <- thisMean + z * thisSE
		}
	}
	
	yLimits <- c(min(as.numeric(ci.l)), max(as.numeric(ci.h)))
	if(!is.null(ylow)) yLimits[1] <- ylow
	if(!is.null(yhi))  yLimits[2] <- yhi
	plot(NA, xlim = xLimits, ylim = yLimits, ...)
	theseMeans <- matrix(ncol = length(orderedVarNames), nrow = grp_k)

	plotVals <- 1:grp_k
	if(!is.null(useTrialNums)) plotVals <- useTrialNums
	
	
		for(i in seq_along(orderedVarNames)){
		vn <- orderedVarNames[i]
		for(j in 1:grp_k){
			ci.l[j,i] -> thisLower
			ci.h[j,i] -> thisUpper
			thisMean <- (thisUpper + thisLower) /2
			theseMeans[j,i] <- thisMean
			lines(c(i + j * adj_x, i+j * adj_x) , c(thisLower, thisUpper), col = cols[j])
			lines(c(i-0.2+j * adj_x, i+0.2+j * adj_x), c(thisLower, thisLower), col = cols[j])
			lines(c(i-0.2+j * adj_x, i+0.2+j * adj_x), c(thisUpper, thisUpper), col = cols[j])
	#		lines(c(i-0.1+j/10, i+0.1+j/10), c(thisMean, thisMean), col = cols[j])
		}
	}
for(i.c in seq_along(plotVals)){
  i <- plotVals[i.c]
  thisCol <- cols[i]
  lines(1:length(orderedVarNames) + i * adj_x, theseMeans[i,], col = cols[i], type = 'b', pch = 16)
  }
}


rankAnalysisClass <- setRefClass('rankAnalysisClass',
                                 fields = c('coefficients', 'varianceMat', 
                                            'rankValues', 'rawData', 'df',
                                            '.lmFit'),
                                 methods = list(
                                   makeSummary = function(){
                                   betas <- coefficients
                                   se <- sqrt(diag(varianceMat))
                                   tval <- betas / se
                                   pval <- 2 * pt(-abs(tval), df = df)
                                   ans <- data.frame(Estimate = coefficients, SE = se, t_value = tval, p_value = pval)
                                   return(ans)
                                 },
                                 show = function(){
                                   print(makeSummary())
                                 }))

summary.rankAnalysisClass <- function(object, ...) object$makeSummary()




getFactorCoef <- function(coefs, factorName, levelName){
  cNames <- names(coefs)
  factorInd <- which(grepl(factorName, cNames) & grepl(levelName, cNames))
  if(length(factorInd) != 1){
    cat('factor name = ', factorName, 'level name = ', levelName, 'matches = ', cNames[factorInd])
    stop('number of factors found not equal to 1. Could be that level name is not unique (or subset of another phrase)')
  }
  return(coefs[factorInd])
}



makeQuantCuts <- function(vals, 
                          percentiles = c(0,0.25,0.5,0.75,1), 
                          numeric_ans = TRUE){
  cutVals <- quantile(vals, percentiles)
  ans <- cut(vals, cutVals)
  if(numeric_ans) ans <- as.numeric(ans)
  return(ans)
}


adjustForCohort <- function(scores, fit, varName = 'cohort'){
  unadjustedScores <- scores
  if(is(fit, 'rankAnalysisClass') ){
    varLevels <- levels(fit$rawData[[varName]])
    dataSet <- fit$rawData
  }
  if(is(fit, 'lm')){
    varLevels <- fit$xlevels[[varName]]
    dataSet <- fit$model
  }
    adjustedScores <- unadjustedScores

    if(length(varLevels) > 1){
      for(i in 2:length(varLevels)){
        lvl = varLevels[i]
        thisCoef <- getFactorCoef(fit$coefficients, varName, lvl)
        theseInds <- dataSet[[varName]] == lvl
        adjustedScores[theseInds] <- adjustedScores[theseInds] - thisCoef
      }
    }
  return(adjustedScores)
}
